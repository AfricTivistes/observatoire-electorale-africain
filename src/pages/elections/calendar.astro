---
import Layout from '../../layouts/MainLayout.astro';
import PageHeader from '../../components/PageHeader.tsx';
import { FaCalendarAlt } from 'react-icons/fa';
import FilterSidebar from '../../components/common/FilterSidebar';
import ElectionSection from '../../components/elections/ElectionSection';
import YearTimeline from '../../components/elections/YearTimeline';

// Importer la collection elections
import { getCollection } from 'astro:content';

// Récupérer les données des élections depuis la collection
const elections = await getCollection('elections');


// Filtrer les élections à venir et en préparation
const filteredElections = elections
  .filter(election => 
    election.data.statut === "À venir" || 
    election.data.statut === "En préparation"
  )
  .sort((a, b) => 
    new Date(a.data.dateElection).getTime() - new Date(b.data.dateElection).getTime()
  );

// Organiser les élections par statut
const upcomingElections = filteredElections.filter(e => e.data.statut === "À venir");
const preparingElections = filteredElections.filter(e => e.data.statut === "En préparation");

// Créer un calendrier pour les 24 prochains mois
const currentDate = new Date();
const months = [];
for (let i = 0; i < 24; i++) {
  const date = new Date(currentDate.getFullYear(), currentDate.getMonth() + i, 1);
  months.push({
    month: date.toLocaleString('fr-FR', { month: 'long' }),
    year: date.getFullYear(),
    date: date
  });
}

// Organiser les élections par mois
const allElections = [...upcomingElections, ...preparingElections];
// État des filtres actifs
const activeFilters = {
  year: undefined,
  type: undefined,
  region: undefined
};

const electionsByMonth = months.map(month => {
  const monthElections = allElections.filter(election => {
    const electionDate = new Date(election.data.dateElection);
    return electionDate.getMonth() === month.date.getMonth() && 
           electionDate.getFullYear() === month.date.getFullYear();
  });

  return {
    ...month,
    elections: monthElections
  };
});

// Créer des données pour le graphique de répartition des élections par type
const electionTypes = ['Générale', 'Législative', 'Présidentielle', 'Referendum'];
const electionTypeData = electionTypes.map(type => {
  return {
    type,
    count: allElections.filter(e => e.type_élection === type).length
  };
});

// Régions africaines pour le filtre
const regions = [
  "Afrique du Nord",
  "Afrique de l'Ouest",
  "Afrique Centrale",
  "Afrique de l'Est",
  "Afrique Australe"
];
---

<Layout title="Calendrier Électoral | Observatoire des Élections en Afrique">
  <PageHeader
    title="Calendrier Électoral" 
    subtitle="Consultez les dates des élections et en préparation et à venir"
    breadcrumbs={[
      { label: 'Accueil', href: '/' },
      { label: 'Élections', href: '/elections' },
      { label: 'Calendrier Électoral' }
    ]}
  >
    <FaCalendarAlt className="text-farafina-primary text-3xl" slot="icon" />
  </PageHeader>

  <div class="container mx-auto px-4 py-8">

    <div class="flex flex-col lg:flex-row gap-8">
      <div class="lg:w-1/4">
        <FilterSidebar
          client:load
          sections={[
            {
              title: "Année",
              name: "year",
              options: Array.from(new Set(filteredElections.map(e => new Date(e.data.dateElection).getFullYear())))
                .sort()
                .map(year => ({
                  label: year.toString(),
                  value: year.toString(),
                  count: elections.filter(e => new Date(e.data.dateElection).getFullYear() === year).length
                }))
            },
            {
              title: "Type d'Élection",
              name: "type",
              options: Array.from(new Set(filteredElections.map(e => e.data.typeElection)))
                .sort()
                .map(type => ({
                  label: type,
                  value: type,
                  count: filteredElections.filter(e => e.data.typeElection === type).length
                }))
            },
            {
              title: "Région",
              name: "region",
              options: Array.from(new Set(filteredElections.map(e => e.data.region)))
                .sort()
                .map(region => ({
                  label: region,
                  value: region,
                  count: filteredElections.filter(e => e.data.region === region).length
                }))
            }
          ]}
          onFilterChange={(filters) => {
            console.log('Filtres appliqués:', filters);
          }}
        />
      </div>

      <div class="lg:w-3/4">
        <YearTimeline client:load elections={filteredElections} filters={activeFilters} />

        <ElectionSection 
          client:load
          title="Élections à venir"
          status="À venir"
          icon="calendar"
          elections={upcomingElections}
          filters={activeFilters}
          colorClass="border-farafina-blue"
          onFilterChange={(filters) => {
            const filtered = elections.filter(election => {
              if (filters.year && new Date(election.data.dateElection).getFullYear().toString() !== filters.year) return false;
              if (filters.type && election.data.typeElection !== filters.type) return false;
              if (filters.region && election.data.region !== filters.region) return false;
              return true;
            });
            return filtered;
          }}
        />

      </div>
    </div>
  </div>
</Layout>